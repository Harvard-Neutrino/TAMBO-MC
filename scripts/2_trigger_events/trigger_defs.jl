using Distributions
using Random

function accept_all(e) :: Float64
    return 1.0
end

function reject_all(e) :: Float64
    return 0.0
end

function interpolated_electron_efficiency(e) :: Float64
    interpolated_eff = interpolated_eff_electron
    lower_limit = extrema(interpolated_eff.itp.knots[1])[begin]
    upper_limit = extrema(interpolated_eff.itp.knots[1])[end]

    if e < lower_limit
        return 0.0
    elseif e > upper_limit
        return interpolated_eff(upper_limit)
    else
        return interpolated_eff(e)
    end
end

function interpolated_muon_efficiency(e) :: Float64
    interpolated_eff = interpolated_eff_muon
    lower_limit = extrema(interpolated_eff.itp.knots[1])[begin]
    upper_limit = extrema(interpolated_eff.itp.knots[1])[end]

    if e < lower_limit
        return 0.0
    elseif e > upper_limit
        return interpolated_eff(upper_limit)
    else
        return interpolated_eff(e)
    end
end

function interpolated_gamma_efficiency(e) :: Float64
    interpolated_eff = interpolated_eff_gamma
    lower_limit = extrema(interpolated_eff.itp.knots[1])[begin]
    upper_limit = extrema(interpolated_eff.itp.knots[1])[end]

    if e < lower_limit
        return 0.0
    elseif e > upper_limit
        return interpolated_eff(upper_limit)
    else
        return interpolated_eff(e)
    end
end

function get_nhit(hit_map, efficiencies)
#function get_nhit(hit_map, efficiencies::Dict{Int, Function})
    nhit = 0
    for hits in values(hit_map)
        nhit += sum([corsika_int_weight(hit, efficiencies) for hit in hits])
    end
    return nhit
end

function did_trigger(
    hit_map,
    module_trigger_thresh::Int=3,
    event_trigger_thresh::Int=30, # Note that this is either in number of incident particle or number of photons created depending on trigger type
    trigger_type::String="whitepaper"
)
    pids = Int[]
    for hits in values(hit_map)
        for hit in hits
            if hit.pdg in pids
                continue
            end
            push!(pids, hit.pdg)
        end
    end

    if trigger_type == "whitepaper"
        efficiencies = Dict(pid => accept_all for pid in pids)
    elseif trigger_type == "threeamigos"
        efficiencies = Dict()
        for pid in pids
            if pid == 11 || pid == 22 || pid == 13 # TODO: antiparticles?
                efficiencies[pid] = accept_all
            else
                efficiencies[pid] = reject_all
            end
        end
    elseif trigger_type == "icetop_tanks" || trigger_type == "icetop_panels"
        efficiencies = Dict()
        for pid in pids
            if pid == 11
                efficiencies[pid] = interpolated_electron_efficiency
            elseif pid == 13
                efficiencies[pid] = interpolated_muon_efficiency
            elseif pid == 22
                efficiencies[pid] = interpolated_gamma_efficiency
            else
                efficiencies[pid] = reject_all
            end
        end
    end

    return did_trigger(
        hit_map,
        efficiencies,
        module_trigger_thresh,
        event_trigger_thresh
    )
end

function did_trigger(
    hit_map,
    efficiencies,
    #efficiencies::Dict{Int, Function},
    module_trigger_thresh::Int=3, # Number of particles or photons that must hit / be generated by a module to trigger it
    event_trigger_thresh::Int=30
)
    hit_map = filter( # Each entry in the hit_map is a vector of CorsikaEvents that hit a single module
        kv->sum(corsika_int_weight(kv[2], efficiencies)) >= module_trigger_thresh,
        hit_map
    )
    if length(hit_map) < 3 # At least this many modules must trigger (pass module_trigger_thresh)
        return false
    end
    
    nhit = get_nhit(hit_map, efficiencies)
    return nhit >= event_trigger_thresh
end

function corsika_int_weight(
    event::Tambo.CorsikaEvent,
    efficiencies
)::Int
    seed = mod(hash(event), 2^32)
    return corsika_int_weight(event, efficiencies, seed)
end

function corsika_int_weight(
    event::Tambo.CorsikaEvent,
    efficiencies,
    seed::Int
) :: Int
    Random.seed!(seed)
    efficiency = efficiencies[event.pdg]

    # First if statement is for case we're counting particle hit, not photons
    if efficiency === accept_all || efficiency === reject_all
        ϵ = efficiency(event.kinetic_energy)
        if rand() > ϵ
            return 0
        end
        weight = event.weight
        if weight > 1
            weight = rand(Poisson(weight))
        end
        return weight
    end

    n_photons = round(efficiency(event.kinetic_energy)) # TODO: add statistical fluctuations
    return n_photons
end

function corsika_int_weight(
    events::Vector{Tambo.CorsikaEvent},
    efficiencies
) :: Vector{Int}
    return [corsika_int_weight(event, efficiencies) for event in events]
end
